"""
app/core/blockchain.py
───────────────────────
Web3.py wrapper for interacting with the KYCRegistry smart contract.

SECURITY:
- The deployer private key (for registering KYC hashes from backend) is loaded
  from environment variables, never hardcoded.
- User private keys NEVER touch this module — consent signatures are verified
  via ECDSA (see security.py), but signing happens client-side.
- All contract calls are wrapped in try/except to surface chain errors cleanly.
"""

import json
import os
from pathlib import Path
from typing import Optional

from web3 import Web3
from eth_account import Account

from app.core.config import get_settings

settings = get_settings()

# Path to compiled ABI (generated by `npx hardhat compile`)
ABI_PATH = Path(__file__).parent.parent.parent.parent / "artifacts" / "contracts" / "KYCRegistry.sol" / "KYCRegistry.json"


class BlockchainClient:
    """
    Singleton-style client for the KYCRegistry smart contract.
    Instantiated once and reused across request lifecycle.
    """

    def __init__(self):
        self.w3 = Web3(Web3.HTTPProvider(settings.BLOCKCHAIN_RPC_URL))
        # Hardhat local network does not need PoA middleware

        # Load contract ABI
        self.contract = None
        self._load_contract()

        # Backend signer (for registerKYCHash calls from server)
        # SECURITY: This is the PLATFORM account only, not a user key.
        if settings.DEPLOYER_PRIVATE_KEY:
            self.deployer_account = Account.from_key(settings.DEPLOYER_PRIVATE_KEY)
        else:
            self.deployer_account = None

    def _load_contract(self):
        """Load contract ABI from Hardhat artifact JSON."""
        try:
            if ABI_PATH.exists():
                with open(ABI_PATH) as f:
                    artifact = json.load(f)
                abi = artifact["abi"]
            else:
                # Fallback: minimal ABI embedded for resilience during development
                abi = self._minimal_abi()

            if settings.KYC_CONTRACT_ADDRESS:
                self.contract = self.w3.eth.contract(
                    address=Web3.to_checksum_address(settings.KYC_CONTRACT_ADDRESS),
                    abi=abi,
                )
        except Exception as e:
            print(f"[Blockchain] Contract load warning: {e}")

    def is_connected(self) -> bool:
        try:
            return self.w3.is_connected()
        except Exception:
            return False

    # ── Contract Calls ───────────────────────────────────────────────────────

    def register_kyc_hash(
        self,
        user_address: str,
        kyc_hash_bytes32: bytes,
        ipfs_cid: str,
        validity_days: int,
        user_private_key: Optional[str] = None,
    ) -> str:
        """
        Call registerKYCHash() on behalf of the user.

        In MVP: backend sends TX using the deployer account for simplicity.
        In prod: user signs the TX client-side and backend relays it (meta-tx).

        Returns: transaction hash (hex string)
        """
        if not self.contract:
            raise RuntimeError("Contract not initialized")

        # Use user key if provided (meta-tx), else fall back to deployer
        account = (
            Account.from_key(user_private_key)
            if user_private_key
            else self.deployer_account
        )
        if not account:
            raise RuntimeError("No signing account available")

        checksummed = Web3.to_checksum_address(user_address)
        nonce = self.w3.eth.get_transaction_count(account.address)
        gas_price = self.w3.eth.gas_price

        tx = self.contract.functions.registerKYCHash(
            kyc_hash_bytes32, ipfs_cid, validity_days
        ).build_transaction(
            {
                "from": account.address,
                "nonce": nonce,
                "gas": 300_000,
                "gasPrice": gas_price,
            }
        )

        signed = account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)
        return tx_hash.hex()

    def request_access(self, bank_account: Account, user_address: str) -> str:
        """Bank requests access to a user's KYC."""
        if not self.contract:
            raise RuntimeError("Contract not initialized")

        nonce = self.w3.eth.get_transaction_count(bank_account.address)
        tx = self.contract.functions.requestAccess(
            Web3.to_checksum_address(user_address)
        ).build_transaction(
            {
                "from": bank_account.address,
                "nonce": nonce,
                "gas": 200_000,
                "gasPrice": self.w3.eth.gas_price,
            }
        )
        signed = bank_account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)
        return tx_hash.hex()

    def grant_consent(self, user_account: Account, bank_address: str) -> str:
        """User grants consent to a bank."""
        if not self.contract:
            raise RuntimeError("Contract not initialized")

        nonce = self.w3.eth.get_transaction_count(user_account.address)
        tx = self.contract.functions.grantConsent(
            Web3.to_checksum_address(bank_address)
        ).build_transaction(
            {
                "from": user_account.address,
                "nonce": nonce,
                "gas": 150_000,
                "gasPrice": self.w3.eth.gas_price,
            }
        )
        signed = user_account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)
        return tx_hash.hex()

    def revoke_consent(self, user_account: Account, bank_address: str) -> str:
        """User revokes consent from a bank."""
        if not self.contract:
            raise RuntimeError("Contract not initialized")

        nonce = self.w3.eth.get_transaction_count(user_account.address)
        tx = self.contract.functions.revokeConsent(
            Web3.to_checksum_address(bank_address)
        ).build_transaction(
            {
                "from": user_account.address,
                "nonce": nonce,
                "gas": 100_000,
                "gasPrice": self.w3.eth.gas_price,
            }
        )
        signed = user_account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed.rawTransaction)
        return tx_hash.hex()

    def has_consent(self, user_address: str, bank_address: str) -> bool:
        """Read-only consent check (no gas needed)."""
        if not self.contract:
            return False
        return self.contract.functions.hasConsent(
            Web3.to_checksum_address(user_address),
            Web3.to_checksum_address(bank_address),
        ).call()

    def get_kyc_record(self, user_address: str) -> dict:
        """Fetch KYC record struct from chain."""
        if not self.contract:
            raise RuntimeError("Contract not initialized")
        record = self.contract.functions.getKYCRecord(
            Web3.to_checksum_address(user_address)
        ).call()
        return {
            "kycHash": record[0].hex(),
            "ipfsCID": record[1],
            "registeredAt": record[2],
            "expiresAt": record[3],
            "isVerified": record[4],
        }

    def get_events(self, event_name: str, from_block: int = 0) -> list:
        """Fetch emitted events for audit log (off-chain indexing)."""
        if not self.contract:
            return []
        event = getattr(self.contract.events, event_name)
        return event.get_logs(fromBlock=from_block)

    @staticmethod
    def _minimal_abi() -> list:
        """
        Minimal ABI subset for development when artifacts haven't been compiled yet.
        In production, always use the compiled Hardhat artifact JSON.
        """
        return [
            {
                "inputs": [
                    {"name": "_kycHash", "type": "bytes32"},
                    {"name": "_ipfsCID", "type": "string"},
                    {"name": "_validityDays", "type": "uint256"},
                ],
                "name": "registerKYCHash",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function",
            },
            {
                "inputs": [{"name": "_user", "type": "address"}],
                "name": "requestAccess",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function",
            },
            {
                "inputs": [{"name": "_bank", "type": "address"}],
                "name": "grantConsent",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function",
            },
            {
                "inputs": [{"name": "_bank", "type": "address"}],
                "name": "revokeConsent",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function",
            },
            {
                "inputs": [
                    {"name": "_user", "type": "address"},
                    {"name": "_bank", "type": "address"},
                ],
                "name": "hasConsent",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function",
            },
        ]


# Module-level singleton — imported by API routers
blockchain_client = BlockchainClient()
